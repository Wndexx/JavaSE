package com.wndexx.java;

/**
	程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象
	
	进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。-------生命周期
	
		程序是静态的，进程是动态的
		
		进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域
		
	线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。
	
		若一个进程同一时间并行执行多个线程，就是支持多线程的
	
		线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小
	
		一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患
	
	单核CPU和多核CPU的理解
	
		单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。
	
		如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）
		
		一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。
		
	并行与并发
	
		并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事
		
		并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事
		
	单核CPU只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短
	
	多线程程序的优点：
	
		1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
		
		2. 提高计算机系统CPU的利用率
		
		3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改
		
	何时需要多线程
	
		程序需要同时执行两个或多个任务。
		
		程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。
		
		需要一些后台运行的程序时
		
	进程可以细化为多个线程
		
		每个线程，拥有自己独立的：栈、程序计数器
		
		多个线程，共享同一个进程中的结构：方法区、堆
		
	Java中的线程分为两类：
	
		一种是守护线程，一种是用户线程。
		
		它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。
		
		主线程(main()) 是一个用户线程
		
		守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true) 可以把一个用户线程变成一个守护线程。Java垃圾回收就是一个典型的守护线程。若JVM中都是守护线程，当前JVM将退出。
 
	多线程的创建方式一：继承于 Thread 类
	
		1. 创建一个继承于 Thread 类的子类
		
		2. 重写 Thread 类 run() -----> 将此线程执行的操作声明在 run() 中
		
		3. 创建 Thread 类的子类的对象
		
		4. 通过此对象调用 start()

	例子：遍历 100 以内所有的偶数

*/

// 1. 创建一个继承于 Thread 类的子类
class MyThread extends Thread {
    // 2. 重写 Thread 类 run()
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0)
                System.out.println(Thread.currentThread().getName() + ":" + i);
        }
    }
}

public class ThreadTest {
    public static void main(String[] args) {
        // 3. 创建 Thread 类的子类的对象
        MyThread t1 = new MyThread();

        // 4. 通过此对象调用 start()
        // (1) 启动当前线程  Causes this thread to begin execution;
        // (2) 调用当前线程的 run()  the Java Virtual Machine calls the run method of this thread
        t1.start();

        // 问题一：我们不能通过直接调用 run() 的方式启动线程
        // t1.run();

        // 问题二：再启动一个线程，遍历 100 以内的偶数
        // 不可以还让已经 start() 的线程去执行，会报 IllegalThreadStateException
        // t1.start();
        // 我们需要重新创建一个线程的对象
        MyThread t2 = new MyThread();
        t2.start();

        // 如下的操作仍然是在 main 线程中执行的
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0)
                System.out.println(Thread.currentThread().getName() + ":" + i + "***********main()*************");
        }
    }
}


