/*
    1. abstract 能修饰哪些结构？修饰以后，有什么特点？

        abstract 修饰类：抽象类 

            (1) 此类不能实例化

            (2) 抽象类中一定有构造器，便于子类实例化时调用

            (3) 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作
        
        abstract 修饰方法：抽象方法

            (1) 抽象方法只有方法的声明，没有方法体

            (2) 包含抽象方法的类一定是一个抽象类。反之，抽象类中是可以没有抽象方法的

            (3) 若子类重写了父类中的所有的抽象方法后，此子类方可实例化

                若子类没有重写父类中的所有的抽象方法后，则次子类也必须是一个抽象类，需要使用 abstract 修饰


        类、方法

        类不能实例化，提供子类

        抽象方法，只定义了一种功能的标准。具体的执行，需要子类去实现


    2. 接口是否能继承接口？抽象类是否能实现(implements)接口？ 抽象类是否能继承非抽象的类？

        接口与接口之间可以继承，而且可以多继承

        抽象类能实现(implements)接口

        抽象类能继承非抽象的类(一个抽象类没有明确指明父类，默认是 Object 类)


    3. 声明抽象类，并包含抽象方法。测试类中创建一个继承抽象类的匿名子类的对象

       abstract class A{
           abstract void m();
       }

       class test{
           public static void main(String[] args){
               A a = new A(){
                   void m(){

                   }
               }
           }
       }


       class Person{
           String name;
           void eat();
       }

      class test{
           public static void main(String[] args){
                Person p = new Person(){
                void eat();
           }
           p.eat();
       }


    4. 抽象类和接口有哪些共同点和区别？

        共同点:

            (1) 不能实例化

            (2) 可以被类继承或实现

            (3) 可以包含抽象方法

            (4) 并列的两个体系

        不同点：

            (1) 抽象类有构造器，接口没有构造器

            (2) 一个类只能继承一个抽象类，但可以继承多个接口

        待完善

    5. 如何创建静态成员内部类和非静态成员内部类的对象？

        静态成员内部类：A.B b = new A.B();

        非静态成员内部类：

            A a = new A();
        
            A.B b = a.new B();

*/