package com.wndexx.java4;

/*
	面向对象特征之三：多态性(Polymorphism)
	
	1. 理解多态性：可以理解为一个事物的多种形态
	
	2. 何为多态性：
	
		- 对象的多态性：父类的引用指向子类的对象 (或子类的对象赋给父类的引用)
	
	3. 多态的使用：虚拟方法调用 (Virtual Method Invocation)  多态是运行时行为
	
		- 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，实际执行的是子类重写父类的方法
		
			- 虚拟方法调用(多态情况下)：子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。
			
			- 编译时类型和运行时类型：编译时为父类型，而方法的调用是在运行时确定的，所以调用的是子类的重写的方法。------ 动态绑定
		
		总结：编译，看左边；运行，看右边
		
	4. 多态性的使用前提：
	
		- 要有类的继承关系
		
		- 方法的重写
		
	5. 对象的多态性，只适用于方法，不适用于属性 (编译和运行都看左边)
	
	
	方法的重载与重写
	
	1. 二者的定义细节：略
	
	2. 从编译和运行的角度看：
	
		- 重载，是指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同的参数列表，对同名方法的名称作修饰。
		
		  对于编译器而言，这些同名方法就构成了不同的方法。它们的调用地址在编译期就绑定了。Java 的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法
		  
		  所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为 "早绑定" 或 "静态绑定"
		  
		  而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为 "晚绑定" 或 "动态绑定" 
	
*/
public class PersonTest {

	public static void main(String[] args) {
		
		Person p1 = new Person();
		p1.eat();
		
		Man man = new Man();
		man.eat();
		man.age = 25;
		man.earnMoney();
		
		System.out.println("***********************************************");
		
		// 对象的多态性：父类的引用指向子类的对象
		Person p2 = new Man();
		// Person p3 = new Woman();
		// 多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法 ------------- 虚拟方法调用
		p2.eat(); 
		p2.walk();
		
		// 编译的时候看左边声明的类型，如果该类型没有对应方法，就不能调用
		// p2.earnMoney(); // The method earnMoney() is undefined for the type Person
		
		System.out.println(p2.id); // 1001
		
	}
}
